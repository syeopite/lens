{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Lens is a multi-format internationalization (i18n) shard for Crystal. It's simple to use and contains everything you'll need to internationalize your application! Supported formats GNU Gettext (support for both .mo and .po) Ruby YAML More coming soon! See their respective documentations!","title":"Introduction"},{"location":"#introduction","text":"Lens is a multi-format internationalization (i18n) shard for Crystal. It's simple to use and contains everything you'll need to internationalize your application!","title":"Introduction"},{"location":"#supported-formats","text":"GNU Gettext (support for both .mo and .po) Ruby YAML More coming soon! See their respective documentations!","title":"Supported formats"},{"location":"getting-started/","text":"Getting Started Why use Lens? Lens was conceived due to various problems within crystal's internationalization ecosystem. As such, Lens aspires to overcome those issues. With lens: Support of multiple different formats Constant development of new features And soon, actual full number and time localization through CLDR In short, Lens is packed full of features and designed for internationalizing. Installation Lens is written in pure crystal and without any external dependencies besides Crystal itself. Thus, installing is as simple as appending Lens to your shard.yml ! dependencies : lens : github : syeopite/lens version : ~> 0.2.0 After which, you just run shards install and Lens would be installed. Usage First let's import Lens into our program require \"lens\" Now we'll select a format! Info See here for information regarding each format. Format Backend Documentation GNU Gettext PO Gettext::POBackend Here GNU Gettext MO Gettext::MOBackend Here Ruby YAML RubyI18n::Yaml 1 Here For this simple illustration lets use Gettext::MOBackend . To get started we just simply initialize it with the locale directory: Gettext :: MOBackend . new ( \"locales\" ) And then call #create catalogue_hash = Gettext :: MOBackend . create () catalogue_hash # => Hash(String, Catalogue) or LanguageCode | Filename => Catalogue catalogue = catalogue_hash [ \"en_US\" ] Danger The API and behaviors for each backend are different ! This is to preserve how the format typically handles stuff. API differences: # The Gettext backends requires a #create method. This returns an Hash of # language code (or file name when the corresponding header isn't defined) # to Catalogue objects gettext_catalogue_hash = Gettext :: MOBackend . new ( \"locales\" ) . create gettext_catalogue = gettext_catalogue [ \"en_US\" ] # The backend for ruby-yaml on the other hand is directly the catalogue. # No need for an additional #create. And naturally, it's also not a hash. yaml_catalogue = RubyI18n :: Yaml . new ( \"locales\" ) # Gettext gettext_catalogue . gettext ( \"A message\" ) # => \"Translated message\" gettext_catalogue . ngettext ( \"I have %d apple\" , \"I have %d apples\" , 50 ) # => \"Translated I have %d apples\" # Ruby YAML yaml_catalogue . translate ( \"en\" , \"translation\" ) # => \"Translated Message\" catalogue . translate ( \"en\" , \"possessions.fruits.apples\" , 50 ) # => \"I have 50 apples\" Behavior differences: yaml_catalogue . translate ( \"en\" , \"I don't exist\" ) # => raises LensExceptions::MissingTranslation gettext_catalogue . gettext ( \"I don't exist\" ) # => \"I don't exist\" In the future there would be a chain backend, and a configuration option will be provided to migrate behavior differences. However, the API for individual backends would always be different. Keep all of this in mind using Lens! After which, we're able to freely translate! # Basic catalogue . gettext ( \"A message\" ) # => \"Translated message\" # Plurals catalogue . ngettext ( \"I have %d apple\" , \"I have %d apples\" , 1 ) # => \"Translated I have %d apples\" # Context catalogue . pgettext ( \"CopyPasteMenu\" , \"copy\" ) # => \"Translated copy\" # Context w/ Plurals catalogue . npgettext ( \"CopyPasteMenu\" , \"Export %d file\" , \"Export %d files\" , 1 ) # => \"Translated message with plural-form 0\" Ruby YAML is the typical format seen in Crystal's internationalization ecosystem. However, each implementation often comes with minor adjustments tailored to their own APIs. Lens' version personally leans more towards the original RubyI18n version. \u21a9","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#why-use-lens","text":"Lens was conceived due to various problems within crystal's internationalization ecosystem. As such, Lens aspires to overcome those issues. With lens: Support of multiple different formats Constant development of new features And soon, actual full number and time localization through CLDR In short, Lens is packed full of features and designed for internationalizing.","title":"Why use Lens?"},{"location":"getting-started/#installation","text":"Lens is written in pure crystal and without any external dependencies besides Crystal itself. Thus, installing is as simple as appending Lens to your shard.yml ! dependencies : lens : github : syeopite/lens version : ~> 0.2.0 After which, you just run shards install and Lens would be installed.","title":"Installation"},{"location":"getting-started/#usage","text":"First let's import Lens into our program require \"lens\" Now we'll select a format! Info See here for information regarding each format. Format Backend Documentation GNU Gettext PO Gettext::POBackend Here GNU Gettext MO Gettext::MOBackend Here Ruby YAML RubyI18n::Yaml 1 Here For this simple illustration lets use Gettext::MOBackend . To get started we just simply initialize it with the locale directory: Gettext :: MOBackend . new ( \"locales\" ) And then call #create catalogue_hash = Gettext :: MOBackend . create () catalogue_hash # => Hash(String, Catalogue) or LanguageCode | Filename => Catalogue catalogue = catalogue_hash [ \"en_US\" ] Danger The API and behaviors for each backend are different ! This is to preserve how the format typically handles stuff. API differences: # The Gettext backends requires a #create method. This returns an Hash of # language code (or file name when the corresponding header isn't defined) # to Catalogue objects gettext_catalogue_hash = Gettext :: MOBackend . new ( \"locales\" ) . create gettext_catalogue = gettext_catalogue [ \"en_US\" ] # The backend for ruby-yaml on the other hand is directly the catalogue. # No need for an additional #create. And naturally, it's also not a hash. yaml_catalogue = RubyI18n :: Yaml . new ( \"locales\" ) # Gettext gettext_catalogue . gettext ( \"A message\" ) # => \"Translated message\" gettext_catalogue . ngettext ( \"I have %d apple\" , \"I have %d apples\" , 50 ) # => \"Translated I have %d apples\" # Ruby YAML yaml_catalogue . translate ( \"en\" , \"translation\" ) # => \"Translated Message\" catalogue . translate ( \"en\" , \"possessions.fruits.apples\" , 50 ) # => \"I have 50 apples\" Behavior differences: yaml_catalogue . translate ( \"en\" , \"I don't exist\" ) # => raises LensExceptions::MissingTranslation gettext_catalogue . gettext ( \"I don't exist\" ) # => \"I don't exist\" In the future there would be a chain backend, and a configuration option will be provided to migrate behavior differences. However, the API for individual backends would always be different. Keep all of this in mind using Lens! After which, we're able to freely translate! # Basic catalogue . gettext ( \"A message\" ) # => \"Translated message\" # Plurals catalogue . ngettext ( \"I have %d apple\" , \"I have %d apples\" , 1 ) # => \"Translated I have %d apples\" # Context catalogue . pgettext ( \"CopyPasteMenu\" , \"copy\" ) # => \"Translated copy\" # Context w/ Plurals catalogue . npgettext ( \"CopyPasteMenu\" , \"Export %d file\" , \"Export %d files\" , 1 ) # => \"Translated message with plural-form 0\" Ruby YAML is the typical format seen in Crystal's internationalization ecosystem. However, each implementation often comes with minor adjustments tailored to their own APIs. Lens' version personally leans more towards the original RubyI18n version. \u21a9","title":"Usage"},{"location":"formats/gnu-gettext/","text":"GNU Gettext Is GNU's implementation of the Gettext system and also the most common translation format for libre-software. It has support for plurals, contexts, and contains a vast ecosystem of tools designed for it. The only caveat is that Gettext does not handle how fractional values can affect plural-forms. Gettext usually comes in two containers: A human-readable .po file for translators A binary .mo file for the program. Lens provide support for both of these in the form of Gettext::POBackend and Gettext::MOBackend respectively. Note Lens does not currently offer any method to export .po to .mo . So an external tool would have to be used. Using Gettext As with all backends, the first step is to initialize it with the locale directory. gettext_backend = Gettext :: MOBackend . new ( \"locales\" ) Locale files are searched with the ** glob, so feel free to nest in as many levels as you'd like. Tip There are no API/behavior differences between the po and mo varieties. Anything that is shown to apply to one would also apply to the other. Now you'll just need to call the #create method: catalogue_hash = gettext_backend . create () Which returns a mapping of the language code, as defined via the Language header \u2014 or the file name when it isn't defined, to a Catalogue object. Now, we can begin translating! catalogue = catalogue_hash [ \"en_US\" ] The most basic syntax for translating strings is the #gettext method. If a translation is not found, then the original ID would be returned. catalogue . gettext ( \"A message\" ) # => \"Translated message\" catalogue . gettext ( \"I don't exist\" ) # => \"I don't exist\" Pluralization Plurals are handled through the #ngettext method. The given number is passed to the C expression from the Plural-Forms header, to compute which plural-form to use. catalogue . ngettext ( \"I have %d apple\" , \"I have %d apples\" , 0 ) # => \"Translated I have %d apple\" catalogue . ngettext ( \"I have %d apple\" , \"I have %d apples\" , 1 ) # => \"Translated I have %d apples\" Context A translation can be constrained by a specific context, and can be accessed through the #pgettext method. This is useful to avoid ambiguities with commonly seen strings. catalogue . pgettext ( \"CopyPasteMenu\" , \"copy\" ) # => \"Translated copy\" catalogue . pgettext ( \"CopyPasteMenu\" , \"I don't exist\" ) # => \"I don't exist\" Context w/ pluralization A context-constrained translation can also have plurals, which are accessed through the #npgettext method catalogue . npgettext ( \"CopyPasteMenu\" , \"Export %d file\" , \"Export %d files\" , 0 ) # => \"Translated message with plural-form 1\" catalogue . npgettext ( \"CopyPasteMenu\" , \"Export %d file\" , \"Export %d files\" , 1 ) # => \"Translated message with plural-form 0\"","title":"GNU Gettext"},{"location":"formats/gnu-gettext/#gnu-gettext","text":"Is GNU's implementation of the Gettext system and also the most common translation format for libre-software. It has support for plurals, contexts, and contains a vast ecosystem of tools designed for it. The only caveat is that Gettext does not handle how fractional values can affect plural-forms. Gettext usually comes in two containers: A human-readable .po file for translators A binary .mo file for the program. Lens provide support for both of these in the form of Gettext::POBackend and Gettext::MOBackend respectively. Note Lens does not currently offer any method to export .po to .mo . So an external tool would have to be used.","title":"GNU Gettext"},{"location":"formats/gnu-gettext/#using-gettext","text":"As with all backends, the first step is to initialize it with the locale directory. gettext_backend = Gettext :: MOBackend . new ( \"locales\" ) Locale files are searched with the ** glob, so feel free to nest in as many levels as you'd like. Tip There are no API/behavior differences between the po and mo varieties. Anything that is shown to apply to one would also apply to the other. Now you'll just need to call the #create method: catalogue_hash = gettext_backend . create () Which returns a mapping of the language code, as defined via the Language header \u2014 or the file name when it isn't defined, to a Catalogue object. Now, we can begin translating! catalogue = catalogue_hash [ \"en_US\" ] The most basic syntax for translating strings is the #gettext method. If a translation is not found, then the original ID would be returned. catalogue . gettext ( \"A message\" ) # => \"Translated message\" catalogue . gettext ( \"I don't exist\" ) # => \"I don't exist\"","title":"Using Gettext"},{"location":"formats/gnu-gettext/#pluralization","text":"Plurals are handled through the #ngettext method. The given number is passed to the C expression from the Plural-Forms header, to compute which plural-form to use. catalogue . ngettext ( \"I have %d apple\" , \"I have %d apples\" , 0 ) # => \"Translated I have %d apple\" catalogue . ngettext ( \"I have %d apple\" , \"I have %d apples\" , 1 ) # => \"Translated I have %d apples\"","title":"Pluralization"},{"location":"formats/gnu-gettext/#context","text":"A translation can be constrained by a specific context, and can be accessed through the #pgettext method. This is useful to avoid ambiguities with commonly seen strings. catalogue . pgettext ( \"CopyPasteMenu\" , \"copy\" ) # => \"Translated copy\" catalogue . pgettext ( \"CopyPasteMenu\" , \"I don't exist\" ) # => \"I don't exist\"","title":"Context"},{"location":"formats/gnu-gettext/#context-w-pluralization","text":"A context-constrained translation can also have plurals, which are accessed through the #npgettext method catalogue . npgettext ( \"CopyPasteMenu\" , \"Export %d file\" , \"Export %d files\" , 0 ) # => \"Translated message with plural-form 1\" catalogue . npgettext ( \"CopyPasteMenu\" , \"Export %d file\" , \"Export %d files\" , 1 ) # => \"Translated message with plural-form 0\"","title":"Context w/ pluralization"},{"location":"formats/ruby-yaml/","text":"Ruby YAML Is the YAML format used by ruby-i18n and the format implemented by all of the internationalization libraries in Crystal prior to Lens. See here for more information regarding the format. Ruby YAML has support for plurals, defined with CLDR data. This means that it can handle plural forms of both Integers and floating point numbers. However, this has not been added to Lens as of writing. Expect to see it in either v0.2.0 or v0.3.0 . Using Ruby YAML The Ruby YAML backend is the RubyI18n::Yaml . To initialize, simply pass in the locale directory: catalogue = RubyI18n :: Yaml . new ( \"locales\" ) Now, we can begin translating! The most basic syntax for translating is just the #translate method. Simply pass in the language code for that specific locale and the key for the specific translation. catalogue . translate ( \"en\" , \"translation\" ) # => \"Translated Message\" catalogue . translate ( \"en\" , \"I don't exist!\" ) # raises LensExceptions::MissingTranslation Tip If you'd like to use Ruby YAML monolingually, you can use the #select method to set a specific language for translations. catalogue . select ( \"en\" ) catalogue . translate ( \"translation\" ) # => \"Translated Message\" Nested keys can be accessed by separating routes with . catalogue . translate ( \"en\" , \"nested_key.forth.forth-third.forth-third-fifth.4344\" ) Pluralization Messages requiring plurals are handled by passing in a number to the #translate method: catalogue . translate ( \"en\" , \"possessions.fruits.apples\" , 50 ) # => \"I have 50 apples\" catalogue . translate ( \"en\" , \"possessions.fruits.apples\" , 1 ) # => \"I have 1 apple\" Plural-Rules follows CLDR (integers-only for now) and is pre-defined in lens for many languages. If your language isn't included in lens you many define (or even overwrite) a new plural-rule through the CrystalI18n.define_rule method CrystalI18n . define_rule ( \"ar\" , -> ( n : Int32 | Int64 | Float64 ) { case when n == 0 then \"zero\" when n == 1 then \"one\" when n == 2 then \"two\" when 3 .. 10 === n % 100 then \"few\" when 11 .. 99 === n % 100 then \"many\" else \"other\" end }) Interpolation Interpolation is done through keyword arguments in the #translate method # message is 'Hello there, my name is %{name} and I'm a %{profession}`. result = catalogue . translate ( \"en\" , \"introduction.messages\" , name : \"Steve\" , profession : \"programmer\" ) result # => \"Hello there, my name is Steve and I'm a programmer\" Iteration If the value at the given path (key) turns out to be an array then you can pass in the iter argument to select a specific value at the given index catalogue . translate ( \"en\" , \"items.foods\" , iter : 2 ) # => \"Hamburger\"","title":"Ruby YAML"},{"location":"formats/ruby-yaml/#ruby-yaml","text":"Is the YAML format used by ruby-i18n and the format implemented by all of the internationalization libraries in Crystal prior to Lens. See here for more information regarding the format. Ruby YAML has support for plurals, defined with CLDR data. This means that it can handle plural forms of both Integers and floating point numbers. However, this has not been added to Lens as of writing. Expect to see it in either v0.2.0 or v0.3.0 .","title":"Ruby YAML"},{"location":"formats/ruby-yaml/#using-ruby-yaml","text":"The Ruby YAML backend is the RubyI18n::Yaml . To initialize, simply pass in the locale directory: catalogue = RubyI18n :: Yaml . new ( \"locales\" ) Now, we can begin translating! The most basic syntax for translating is just the #translate method. Simply pass in the language code for that specific locale and the key for the specific translation. catalogue . translate ( \"en\" , \"translation\" ) # => \"Translated Message\" catalogue . translate ( \"en\" , \"I don't exist!\" ) # raises LensExceptions::MissingTranslation Tip If you'd like to use Ruby YAML monolingually, you can use the #select method to set a specific language for translations. catalogue . select ( \"en\" ) catalogue . translate ( \"translation\" ) # => \"Translated Message\" Nested keys can be accessed by separating routes with . catalogue . translate ( \"en\" , \"nested_key.forth.forth-third.forth-third-fifth.4344\" )","title":"Using Ruby YAML"},{"location":"formats/ruby-yaml/#pluralization","text":"Messages requiring plurals are handled by passing in a number to the #translate method: catalogue . translate ( \"en\" , \"possessions.fruits.apples\" , 50 ) # => \"I have 50 apples\" catalogue . translate ( \"en\" , \"possessions.fruits.apples\" , 1 ) # => \"I have 1 apple\" Plural-Rules follows CLDR (integers-only for now) and is pre-defined in lens for many languages. If your language isn't included in lens you many define (or even overwrite) a new plural-rule through the CrystalI18n.define_rule method CrystalI18n . define_rule ( \"ar\" , -> ( n : Int32 | Int64 | Float64 ) { case when n == 0 then \"zero\" when n == 1 then \"one\" when n == 2 then \"two\" when 3 .. 10 === n % 100 then \"few\" when 11 .. 99 === n % 100 then \"many\" else \"other\" end })","title":"Pluralization"},{"location":"formats/ruby-yaml/#interpolation","text":"Interpolation is done through keyword arguments in the #translate method # message is 'Hello there, my name is %{name} and I'm a %{profession}`. result = catalogue . translate ( \"en\" , \"introduction.messages\" , name : \"Steve\" , profession : \"programmer\" ) result # => \"Hello there, my name is Steve and I'm a programmer\"","title":"Interpolation"},{"location":"formats/ruby-yaml/#iteration","text":"If the value at the given path (key) turns out to be an array then you can pass in the iter argument to select a specific value at the given index catalogue . translate ( \"en\" , \"items.foods\" , iter : 2 ) # => \"Hamburger\"","title":"Iteration"}]}